/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useMemo, useRef, useState } from "react";
import { useAnimations, useFBX, useGLTF } from "@react-three/drei";
import { useControls } from "leva";
import { useFrame, useLoader } from "@react-three/fiber";
import * as THREE from "three";

import {
  Root,
  Container,
  Text,
  setPreferredColorScheme,
  Content,
  Fullscreen,
} from "@react-three/uikit";

import { Button } from "./apfel/button";
import { Card } from "./apfel/card";

const correspondingVisemes = {
  A: "viseme_PP",
  B: "viseme_kk",
  C: "viseme_I",
  D: "viseme_AA",
  E: "viseme_O",
  F: "viseme_U",
  G: "viseme_FF",
  H: "viseme_TH",
  X: "viseme_PP",
};

export function Avatar(props, { ratioScale }) {
  // const { playAudio, script } = useControls({
  //   playAudio: false,
  //   script: {
  //     value: "intro",
  //     options: ["intro", "make_me"],
  //   },
  // });

  const playAudio = false;
  const script = "intro";

  const [currentAnimation, setCurrentAnimation] = useState("idle");
  const { nodes, materials } = useGLTF("/models/bob_cut.glb");
  const { animations: idleAnimations } = useFBX(
    "/models/animations/Standing_Idle.fbx"
  );
  const { animations: angryAnimations } = useFBX(
    "/models/animations/Angry.fbx"
  );
  const { animations: greetingAnimations } = useFBX(
    "/models/animations/Standing_Greeting.fbx"
  );

  const animationMap = {
    idle: idleAnimations,
    angry: angryAnimations,
    greeting: greetingAnimations,
  };

  const allAnimations = [
    ...idleAnimations,
    ...angryAnimations,
    ...greetingAnimations,
  ];
  allAnimations.forEach((anim, index) => {
    anim.name = `animation_${index}`;
  });

  const group = useRef();

  const { actions } = useAnimations(allAnimations, group);

  useEffect(() => {
    const currentAnimations = animationMap[currentAnimation] || idleAnimations;
    let currentIndex = 0;

    console.log("length", allAnimations.length);

    const playNextAnimation = () => {
      const animationName = `animation_${currentIndex}`;
      console.log("Attempting to play:", animationName);

      if (actions[animationName] && currentIndex < allAnimations.length) {
        console.log("Found animation:", animationName);

        const action = actions[animationName];
        action.reset().fadeIn(0.5).play();

        // Log the total number of animations
        console.log("Total animations:", allAnimations.length);

        // Increment the index, but wrap around to 0 if we've reached the end
        currentIndex = (currentIndex + 1) % allAnimations.length;
        console.log("Next index:", currentIndex);
      } else {
        console.error(
          "Animation not found:",
          animationName,
          "Total animations:",
          allAnimations.length
        );
        // Reset the index if we've gone out of bounds
        currentIndex = 0;
      }
    };

    playNextAnimation();
    const intervalId = setInterval(playNextAnimation, 5000);

    return () => clearInterval(intervalId);
  }, [actions, currentAnimation, animationMap]);

  return (
    <group {...props} dispose={null} ref={group} scale={ratioScale}>
      <primitive object={nodes.Hips} />
      <skinnedMesh
        name="EyeLeft"
        geometry={nodes.EyeLeft.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeLeft.skeleton}
        morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
      />
      <skinnedMesh
        name="EyeRight"
        geometry={nodes.EyeRight.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeRight.skeleton}
        morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Head"
        geometry={nodes.Wolf3D_Head.geometry}
        material={materials.Wolf3D_Skin}
        skeleton={nodes.Wolf3D_Head.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Teeth"
        geometry={nodes.Wolf3D_Teeth.geometry}
        material={materials.Wolf3D_Teeth}
        skeleton={nodes.Wolf3D_Teeth.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Hair.geometry}
        material={materials.Wolf3D_Hair}
        skeleton={nodes.Wolf3D_Hair.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Top.geometry}
        material={materials.Wolf3D_Outfit_Top}
        skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
        material={materials.Wolf3D_Outfit_Bottom}
        skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
        material={materials.Wolf3D_Outfit_Footwear}
        skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Body.geometry}
        material={materials.Wolf3D_Body}
        skeleton={nodes.Wolf3D_Body.skeleton}
      />
    </group>
  );
}

export function CardPage() {
  // useFrame((_, delta) => {
  //   easing.damp(translateY, "value", openRef.current ? 0 : -460, 0.2, delta);
  //   easing.damp(translateZ, "value", openRef.current ? 200 : 0, 0.2, delta);
  // });
  return (
    <Root backgroundColor="red">
      <Button variant="rect" size="sm" platter>
        <Text>Label</Text>
      </Button>
    </Root>
  );
}

useGLTF.preload("/models/model_with_morph_targets.glb");
